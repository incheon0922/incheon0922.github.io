<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content=""><meta name="description" content="个人博客、记录"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer"><title></title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/libs/awesome/css/all.css"><link rel="stylesheet" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/libs/aos/aos.css"><link rel="stylesheet" href="/libs/animate/animate.min.css"><link rel="stylesheet" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/css/matery.css"><link rel="stylesheet" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="stylesheet" href="/css/prism-tomorrow.css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/coderc.png" class="logo-img" alt="LOGO"></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:0.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-list" style="zoom:0.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:0.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:0.6"></i> <span>标签</span></a></li><li><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:0.6"></i> <span>分类</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:0.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:0.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-list" style="zoom:0.6"></i> <span>友链留言</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:0.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><div class="logo-name"></div><div class="logo-desc">个人博客、记录</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-list"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li></ul></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-list"></i> 友链留言</a></li><li><div class="divider"></div></li><li><a href="https://github.com/incheon0922" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{fill:#fff;height:64px;width:64px;color:#18283f}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/incheon0922" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><style>.carousel-control{width:45px;height:45px;line-height:55px;border-radius:45px;background:0 0;cursor:pointer;z-index:100}#prev-cover{position:absolute;top:48%;left:8px}#next-cover{position:absolute;top:48%;right:8px}#prev-cover i{margin-right:3px}#next-cover i{margin-left:3px}.carousel-control:hover{background-color:rgba(0,0,0,.4)}.carousel-control i{color:#fff;font-size:2.4rem}</style><div class="carousel carousel-slider center index-cover" data-indicators="true" style="margin-top:-64px"><div class="carousel-item red white-text bg-cover about-cover"><div class="container"><div class="cover-btns"><a href="#indexCard" class="waves-effect waves-light btn"><i class="fa fa-angle-double-down" style="zoom:1.1;padding-right:5px"></i> 开始阅读</a><a href="https://github.com/incheon0922" class="waves-effect waves-light btn" target="_blank"><i class="fab fa-github-alt" style="zoom:1.1;padding-right:13px"></i> Github</a></div><div class="cover-social-link"><a href="https://github.com/incheon0922" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="https://space.bilibili.com/311652727?spm_id_from=333.1007.0.0" class="tooltipped" target="_blank" data-tooltip="bilibili" data-position="top" data-delay="50"><i class="fab fa-bilibili"></i></a><a href="" class="tooltipped" target="_blank" data-tooltip="<img src='/wechat.jpg' width='128' height='148'/>" data-position="top" data-delay="50"><i class="fab fa-weixin"></i></a></div></div></div></div><script>let canvas;$((function(){let e,n=$(".carousel"),t=!1;n.carousel({duration:Number("120"),fullWidth:!0,indicators:!0,onCycleTo(){var e;t||(e=this,setInterval((()=>{(e.pressed||e.dragged)&&a()}),1e3),t=!0)}});let o=function(){e=setInterval((function(){n.carousel("next")}),5e3)};function a(){clearInterval(e),o()}o(),$("#prev-cover").click((function(){n.carousel("prev"),a()})),$("#next-cover").click((function(){n.carousel("next"),a()}))}));const vertexShaderSource="#version 300 es\n        in vec4 apos;\n\n        void main(){\n\n            gl_Position = apos;\n\n    }\n";let webgl,fragmentShaderSource="#version 300 es\n    precision mediump float;\n\n    uniform vec3  iResolution;\n    uniform float iTime;\n    uniform vec3 iMouse;\n\n    //下面一行作为插入位置，它是一段特定的注释，作为识别并替换成 shadertoy片段 代码用。\n    //=#*INSERT_LOCATION*#=\n\n\n    out vec4 color;\n\n    void main(){\n\n        vec4 col = vec4(0.0 , 0.0 , 0.0 , 1.0);\n        mainImage(col , gl_FragCoord.xy);     //改函数是 shadertoy 固定接口，它会输出一个颜色。\n        color = col ;\n\n    }",sToyTest="\n        vec2 hash21(float p)\n        {\n            vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n            p3 += dot(p3, p3.yzx + 33.33);\n            return fract((p3.xx+p3.yz)*p3.zy);\n\n        }\n\n        vec3 hash31(float p) {\n            vec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n            p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n            return fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n        }\n\n        vec2 dir(float id){\n            vec2 h = hash21(id);\n            h.y*=2.*acos(-1.);\n            return h.x*vec2(cos(h.y),sin(h.y));\n        }\n\n        #define PARTICLES_MIN 20.\n        #define PARTICLES_MAX 200.\n\n        float bang(vec2 uv, float t,float id){\n            float o = 0.;\n            if(t<=0.){\n                return .04/dot(uv,uv);\n            }\n            float s = (sqrt(t)+t*exp2(-t/.125)*.8)*10.;\n            float brightness = sqrt(1.-t)*.015*(step(.0001,t)*.9+.1);\n            float blinkI = exp2(-t/.125);\n            float PARTICLES = PARTICLES_MIN+(PARTICLES_MAX-PARTICLES_MIN)*fract(cos(id)*45241.45);\n            for(float i=0.;i<PARTICLES;i++){\n                vec2 d = dir(i+.012*id);\n\n                vec2 p = d*s;\n\n\n                vec2 h = hash21(5.33345*i+.015*id);\n                float blink = mix(cos((t+h.x)*10.*(2.+h.y)+h.x*h.y*10.)*.3+.7,1.,blinkI);\n\n                o+=blink*brightness/dot(uv-p,uv-p);\n            }\n            return o;\n        }\n\n        const float ExT = 1./4.;\n\n        #define duration 2.2\n\n        float firework(vec2 uv,float t,float id){\n            if(id<1.)return 0.;\n            vec2 h = hash21(id*5.645)*2.-1.;\n            vec2 offset = vec2(h.x*.1,0.);\n            h.y=h.y*.95;\n            h.y*=abs(h.y);\n            vec2 di = vec2(h.y,sqrt(1.-h.y*h.y));\n            float thrust = sqrt(min(t,ExT)/ExT)*25.;\n            vec2 p = offset+duration*(di*thrust+vec2(0.,-9.81)*t)*t;\n            return sqrt(1.-t)*bang(uv-p,max(0.,(t-ExT)/(1.-ExT)),id);\n        }\n\n        #define NUM_ROCKETS 3.\n        void mainImage( out vec4 fragColor, in vec2 fragCoord )\n        {\n            vec2 uv = (2.*fragCoord-iResolution.xy*vec2(1.,0.))/iResolution.y;\n            vec3 col = vec3(.01,.011,.015)*0.;\n\n            float time = .75*iTime;\n            float t = time/duration;\n            uv.y-=.65;\n            uv*=35.;\n            float m = 1.;\n            float d =0.;\n            //water\n            if(uv.y<0.){\n                const float h0 = 5.;\n                const float dcam = 1000.5;\n\n                float y = uv.y-h0;//translated y position, to add fake earth curvature (horizon not at infinity)\n\n                float z = dcam*h0/y;//fake depth\n                d=-40.*uv.y/(h0*dcam);\n\n                float x = uv.x*z/dcam; //parallax-aware x coordinate\n\n                uv+=vec2(sin((x*1.5+z*.75)*.0005-t*1.5),cos((z*2.-x*.5)*.0005-t*2.69))\n                *(sin(x*.07+z*.09+sin(x*.2-t)-t*15.)+cos(z*.1-x*(.08+.001*sin(x*.01-t))-t*16.)*.7+cos(z*.01+x*.004-t*10.)*1.7)\n                *.15*dcam/z; //waves\n\n                float ndv = -uv.y/sqrt(dcam*dcam+uv.y*uv.y);\n                m=mix(1.,.98,pow(1.-ndv,5.));//fresnel factor\n\n                uv.y = -uv.y;\n            }\n            //sky\n            col+=(exp2(-abs(uv.y)*vec3(1.,2.,3.)-.5)+exp2(-abs(uv.y)*vec3(1.,.2,.1)-4.))*.5;\n\n            //land\n            if(uv.y*1.5<(uv.x-20.)*.01*(-uv.x+90.)+sin(uv.x)*cos(uv.y*1.1)*.75)\n                col*=0.;\n\n            for(float i = 0.;i<ceil(NUM_ROCKETS);i++){\n                float T = 1.+t+i/NUM_ROCKETS;\n\n                float id = floor(T)-i/NUM_ROCKETS; //should give a unique integer for each rocket\n\n                vec3 color = hash31(id*.75645);\n                color/=max(color.r,max(color.g,color.b));//making colors as bright as possible\n\n                col+=firework(uv,fract(T),id)*color;\n            }\n            //col = vec3(1);\n            fragColor = vec4(m*col,1.0);\n\n            // vec4 noise = texture(iChannel0,(fragCoord)/iChannelResolution[0].xy);\n            vec4 noise = vec4(0.0);\n            noise = noise*255./256.+noise.w/256.;\n            //linear dithering to avoid banding (linear means less overshoot for dark pixels, so better contrast)\n            vec4 lcol = clamp(fragColor,0.,1.); //clamp input\n            vec4 gcol = pow(lcol,vec4(1./2.2)); //convert to output gamma space\n\n            vec4 gcol_f = floor(gcol*255.)/255.; //floor to get the lower bound\n\n            vec4 lcol_f = pow(gcol_f,vec4(2.2)); // convert the lower bound to linear\n            vec4 lcol_c = pow(ceil(gcol*255.)/255.,vec4(2.2)); // ceil to get the upper bound, convereted to linear\n\n            vec4 x = (lcol-lcol_f)/(lcol_c-lcol_f); // get x such as lcol_f + x*(lcol_c-lcol_f) == lcol\n\n            // compare x to the noise to chose what bounding value should be selected (in gamma space)\n            fragColor = gcol_f+step(noise,x)/255.;\n            fragColor.a = d;\n        }\n    ";sToyTest="\n        #define S smoothstep\n\n        vec4 Line(vec2 uv, float speed, float height, vec3 col) {\n            uv.y += S(1., 0., abs(uv.x)) * sin(iTime * speed + uv.x * height) * .2;\n            return vec4(S(.06 * S(.2, .9, abs(uv.x)), 0., abs(uv.y) - .004) * col, 1.0) * S(1., .3, abs(uv.x));\n        }\n\n        void mainImage(out vec4 O, in vec2 I) {\n            vec2 uv = (I - .5 * iResolution.xy) / iResolution.y;\n            O = vec4 (0.);\n            for (float i = 0.; i <= 5.; i += 1.) {\n                float t = i / 5.;\n                O += Line(uv, 1. + t, 4. + t, vec3(.2 + t * .7, .2 + t * .4, 0.3));\n            }\n        }\n    ",sToyTest="\n\n        // afl_ext 2017-2023\n        // Now with 2023 refresh\n        // MIT License\n\n        // Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n        #define DRAG_MULT 0.28 // changes how much waves pull on the water\n        #define WATER_DEPTH 1.0 // how deep is the water\n        #define CAMERA_HEIGHT 1.5 // how high the camera should be\n        #define ITERATIONS_RAYMARCH 12 // waves iterations of raymarching\n        #define ITERATIONS_NORMAL 40 // waves iterations when calculating normals\n\n        #define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n        // Calculates wave value and its derivative,\n        // for the wave direction, position in space, wave frequency and time\n        vec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\n        float x = dot(direction, position) * frequency + timeshift;\n        float wave = exp(sin(x) - 1.0);\n        float dx = wave * cos(x);\n        return vec2(wave, -dx);\n        }\n\n        // Calculates waves by summing octaves of various waves with various parameters\n        float getwaves(vec2 position, int iterations) {\n        float iter = 0.0; // this will help generating well distributed wave directions\n        float frequency = 1.0; // frequency of the wave, this will change every iteration\n        float timeMultiplier = 2.0; // time multiplier for the wave, this will change every iteration\n        float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n        float sumOfValues = 0.0; // will store final sum of values\n        float sumOfWeights = 0.0; // will store final sum of weights\n        for(int i=0; i < iterations; i++) {\n            // generate some wave direction that looks kind of random\n            vec2 p = vec2(sin(iter), cos(iter));\n            // calculate wave data\n            vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier);\n\n            // shift position around according to wave drag and derivative of the wave\n            position += p * res.y * weight * DRAG_MULT;\n\n            // add the results to sums\n            sumOfValues += res.x * weight;\n            sumOfWeights += weight;\n\n            // modify next octave parameters\n            weight *= 0.82;\n            frequency *= 1.18;\n            timeMultiplier *= 1.07;\n\n            // add some kind of random value to make next wave look random too\n            iter += 1232.399963;\n        }\n        // calculate and return\n        return sumOfValues / sumOfWeights;\n        }\n\n        // Raymarches the ray from top water layer boundary to low water layer boundary\n        float raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {\n        vec3 pos = start;\n        vec3 dir = normalize(end - start);\n        for(int i=0; i < 64; i++) {\n            // the height is from 0 to -depth\n            float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;\n            // if the waves height almost nearly matches the ray height, assume its a hit and return the hit distance\n            if(height + 0.01 > pos.y) {\n            return distance(pos, camera);\n            }\n            // iterate forwards according to the height mismatch\n            pos += dir * (pos.y - height);\n        }\n        // if hit was not registered, just assume hit the top layer,\n        // this makes the raymarching faster and looks better at higher distances\n        return distance(start, camera);\n        }\n\n        // Calculate normal at point by calculating the height at the pos and 2 additional points very close to pos\n        vec3 normal(vec2 pos, float e, float depth) {\n        vec2 ex = vec2(e, 0);\n        float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;\n        vec3 a = vec3(pos.x, H, pos.y);\n        return normalize(\n            cross(\n            a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y),\n            a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)\n            )\n        );\n        }\n\n        // Helper function generating a rotation matrix around the axis by the angle\n        mat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n        float oc = 1.0 - c;\n        return mat3(\n            oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n            oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n            oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n        );\n        }\n\n        // Helper function that generates camera ray based on UV and mouse\n        vec3 getRay(vec2 fragCoord) {\n        vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n        // for fisheye, uncomment following line and comment the next one\n        //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\n        vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n        if(iResolution.x < 600.0) {\n            return proj;\n        }\n        return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0))\n            * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n            * proj;\n        }\n\n        // Ray-Plane intersection checker\n        float intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) {\n        return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0);\n        }\n\n        // Some very barebones but fast atmosphere approximation\n        vec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir) {\n        sundir.y = max(sundir.y, -0.07);\n        float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n        float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n        float raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n        float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n        float mymie = sundt * special_trick * 0.2;\n        vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n        vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n        vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n        bluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n        return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\n        }\n\n        // Calculate where the sun should be, it will be moving around the sky\n        vec3 getSunDirection() {\n        return normalize(vec3(sin(iTime * 0.1), 1.0, cos(iTime * 0.1)));\n        }\n\n        // Get atmosphere color for given direction\n        vec3 getAtmosphere(vec3 dir) {\n        return extra_cheap_atmosphere(dir, getSunDirection()) * 0.5;\n        }\n\n        // Get sun color for given direction\n        float getSun(vec3 dir) {\n        return pow(max(0.0, dot(dir, getSunDirection())), 720.0) * 210.0;\n        }\n\n        // Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\n        vec3 aces_tonemap(vec3 color) {\n        mat3 m1 = mat3(\n            0.59719, 0.07600, 0.02840,\n            0.35458, 0.90834, 0.13383,\n            0.04823, 0.01566, 0.83777\n        );\n        mat3 m2 = mat3(\n            1.60475, -0.10208, -0.00327,\n            -0.53108,  1.10813, -0.07276,\n            -0.07367, -0.00605,  1.07602\n        );\n        vec3 v = m1 * color;\n        vec3 a = v * (v + 0.0245786) - 0.000090537;\n        vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n        return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\n        }\n\n        // Main\n        void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        // get the ray\n        vec3 ray = getRay(fragCoord);\n        if(ray.y >= 0.0) {\n            // if ray.y is positive, render the sky\n            vec3 C = getAtmosphere(ray) + getSun(ray);\n            fragColor = vec4(aces_tonemap(C * 2.0),1.0);\n            return;\n        }\n\n        // now ray.y must be negative, water must be hit\n        // define water planes\n        vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);\n        vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);\n\n        // define ray origin, moving around\n        vec3 origin = vec3(iTime, CAMERA_HEIGHT, iTime);\n\n        // calculate intersections and reconstruct positions\n        float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));\n        float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));\n        vec3 highHitPos = origin + ray * highPlaneHit;\n        vec3 lowHitPos = origin + ray * lowPlaneHit;\n\n        // raymatch water and reconstruct the hit pos\n        float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);\n        vec3 waterHitPos = origin + ray * dist;\n\n        // calculate normal at the hit position\n        vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);\n\n        // smooth the normal with distance to avoid disturbing high frequency noise\n        N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));\n\n        // calculate fresnel coefficient\n        float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\n        // reflect the ray and make sure it bounces up\n        vec3 R = normalize(reflect(ray, N));\n        R.y = abs(R.y);\n\n        // calculate the reflection and approximate subsurface scattering\n        vec3 reflection = getAtmosphere(R) + getSun(R);\n        vec3 scattering = vec3(0.0293, 0.0698, 0.1717) * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);\n\n        // return the combined result\n        vec3 C = fresnel * reflection + (1.0 - fresnel) * scattering;\n        fragColor = vec4(aces_tonemap(C * 2.0), 1.0);\n        }\n    ";let render,time=Date.now(),totalTimeSec=0;function initBuffer(){const e=new Float32Array([-1,-1,0,0,0,-1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,-1,0,1,0,-1,-1,0,0,0]),n=webgl.getAttribLocation(webgl.program,"apos"),t=webgl.createBuffer();webgl.bindBuffer(webgl.ARRAY_BUFFER,t),webgl.bufferData(webgl.ARRAY_BUFFER,e,webgl.STATIC_DRAW),webgl.vertexAttribPointer(n,3,webgl.FLOAT,!1,20,0),webgl.enableVertexAttribArray(n);const o=webgl.getUniformLocation(webgl.program,"iResolution");webgl.uniform3f(o,webgl.canvas.width,webgl.canvas.height,1);const a=webgl.getUniformLocation(webgl.program,"iTime");webgl.uniform1f(a,totalTimeSec);const i=webgl.getUniformLocation(webgl.program,"iMouse");webgl.uniform3f(i,300,100,0)}const renderLoop=()=>{const e=Date.now();totalTimeSec+=.001*(e-time),time=e;const n=webgl.getUniformLocation(webgl.program,"iResolution");webgl.uniform3f(n,webgl.canvas.width,webgl.canvas.height,1);const t=webgl.getUniformLocation(webgl.program,"iTime");webgl.uniform1f(t,totalTimeSec),webgl.drawArrays(webgl.TRIANGLES,0,6),render=requestAnimationFrame(renderLoop)};function destroy(){render&&cancelAnimationFrame(render)}function initShader(e,n,t){if(!e||!n||!t)return;let o;const a=document.getElementById(e);o=n.includes("#version 300 es")||t.includes("#version 300 es")?a.getContext("webgl2"):a.getContext("webgl");const i=o.createShader(o.VERTEX_SHADER),r=o.createShader(o.FRAGMENT_SHADER);if(o.shaderSource(i,n),o.shaderSource(r,t),o.compileShader(i),o.compileShader(r),!o.getShaderParameter(i,o.COMPILE_STATUS)){const e=o.getShaderInfoLog(i);return void console.log(e)}if(!o.getShaderParameter(r,o.COMPILE_STATUS)){const e=o.getShaderInfoLog(r);return void console.log(e)}const c=o.createProgram();return o.attachShader(c,i),o.attachShader(c,r),o.linkProgram(c),o.useProgram(c),o.program=c,o}function init(){$(".carousel-item").removeClass("red"),canvas=document.createElement("canvas"),canvas.height=document.querySelector(".carousel").clientHeight,canvas.width=document.querySelector(".carousel").clientWidth,canvas.id="canvas",canvas.style.background="rgba(0,0,0,1.0)",document.querySelector(".carousel").appendChild(canvas),fragmentShaderSource=fragmentShaderSource.replace("//=#*INSERT_LOCATION*#=",sToyTest),webgl=initShader("canvas",vertexShaderSource,fragmentShaderSource),initBuffer(),renderLoop()}init()</script><main class="content"><div id="indexCard" class="index-card"><div class="container"><div class="card"><div class="card-content"><div id="recommend-sections" class="recommend"></div></div></div></div></div><article id="articles" class="container articles"><div class="row article-row"><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2024/09/12/liu-ti-ke-shi-hua/"><div class="card-image"><img src="/medias/fluid.png" class="responsive-img" alt="流体可视化"> <span class="card-title">流体可视化</span></div></a><div class="card-content article-content"><div class="summary block-with-text">基于cesium实现的流体渲染效果,shaderToy上面有很多关于流体渲染相关的例子，将这些效果移植到cesium上面可以在一定程度上增强水体淹没等三维可视化展示效果。本文结合网上各位大佬的例子，基于高度图采样实现流体渲染，大致思路如下</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2024-09-12</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E4%BD%93%E6%B8%B2%E6%9F%93-%E6%B5%81%E4%BD%93%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%B8%A7%E7%BC%93%E5%86%B2/"><span class="chip bg-color">体渲染 流体可视化 帧缓冲</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2024/05/30/bao-zha-xiao-guo-shi-xian/"><div class="card-image"><img src="https://bu.dusays.com/2024/05/30/66583def251c3.png" class="responsive-img" alt="爆炸效果实现"> <span class="card-title">爆炸效果实现</span></div></a><div class="card-content article-content"><div class="summary block-with-text">基于cesium实现的体渲染爆炸效果 思路实现思路和之前的复刻柏林噪声类似都是体渲染，shader参考的是shaderToy上面的爆炸效果，可以查看下方参考链接 效果展示 参考链接Cesium 体积爆炸效果 体积火 体积烟雾</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2024-05-30</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E4%BD%93%E6%B8%B2%E6%9F%93-%E7%88%86%E7%82%B8%E6%95%88%E6%9E%9C/"><span class="chip bg-color">体渲染 爆炸效果</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2024/02/02/gao-du-wu-ji-liu-dong-xiao-guo-shi-xian/"><div class="card-image"><img src="https://bu.dusays.com/2024/02/02/65bc560b8c432.png" class="responsive-img" alt="高度雾及流动效果实现"> <span class="card-title">高度雾及流动效果实现</span></div></a><div class="card-content article-content"><div class="summary block-with-text">基于高度实现的雾效果，可以在一定程度上优化场景展示，本文基于cesium实现了一版线性高度雾并在此基础上添加了流动效果，大致思路如下 思路1、纹理坐标还原成世界坐标2、计算世界坐标相对于地面的高程值，以及相机坐标与片元之间的距离，并根据高程</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2024-02-02</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%90%8E%E5%A4%84%E7%90%86-%E9%AB%98%E5%BA%A6%E9%9B%BE/"><span class="chip bg-color">后处理 高度雾</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2024/02/01/hou-chu-li-shi-xian-ji-xue-xiao-guo/"><div class="card-image"><img src="https://bu.dusays.com/2024/02/01/65bb9824c0370.png" class="responsive-img" alt="后处理实现积雪效果"> <span class="card-title">后处理实现积雪效果</span></div></a><div class="card-content article-content"><div class="summary block-with-text">cesium有两种思路实现积雪效果，一种渲染在模型等上面，另外一种则是通过后处理的方式。两种方式原理基本相同，但是效果范围以及修改方式有差别，各有取舍吧，本文采用的是后处理方式实现积雪效果 思路1、根据纹理坐标还原世界坐标，将其单位化当作片</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2024-02-01</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%90%8E%E5%A4%84%E7%90%86-%E7%A7%AF%E9%9B%AA/"><span class="chip bg-color">后处理 积雪</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2024/01/04/yin-ying-lu-fen-xi/"><div class="card-image"><img src="https://bu.dusays.com/2024/01/05/659810eeaaf1e.jpg" class="responsive-img" alt="阴影率分析"> <span class="card-title">阴影率分析</span></div></a><div class="card-content article-content"><div class="summary block-with-text">cesium阴影率分析的思路大概有两种，一是开启光照并生成格网点，时钟每tick一次记录太阳的位置，构造格网点到太阳位置的射线，通过射线求交的方法计算累计光照量，但这种方法比较耗时间且复杂，二是通过shadowMap来计算，本文采用的是第二</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2024-01-04</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E9%98%B4%E5%BD%B1-%E7%BA%B9%E7%90%86-%E5%B8%A7%E7%BC%93%E5%86%B2/"><span class="chip bg-color">阴影 纹理 帧缓冲</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2023/12/17/qi-xiang-shu-ju-ti-xuan-ran/"><div class="card-image"><img src="https://bu.dusays.com/2023/12/17/657e8a2348d3a.png" class="responsive-img" alt="气象数据体渲染"> <span class="card-title">气象数据体渲染</span></div></a><div class="card-content article-content"><div class="summary block-with-text">气象数据的体渲染思路和上一篇复刻柏林噪声类似，都是采用三维纹理方式实现采样渲染的，但这里需要注意的是大范围的BoxGeometry在自定以的dc里面传入dimension，进行采样的时候会报错，可能是数据维度太大的问题，需要变换模型矩阵，编</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-12-17</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE-%E4%BD%93%E6%B8%B2%E6%9F%93/"><span class="chip bg-color">气象数据 体渲染</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2023/12/16/fu-ke-bo-lin-zao-sheng/"><div class="card-image"><img src="https://bu.dusays.com/2023/12/17/657e62fb7f46e.png" class="responsive-img" alt="复刻柏林噪声"> <span class="card-title">复刻柏林噪声</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Three.js里面有很多关于体渲染的例子，柏林噪声就是其中比较好的一个。在cesium中复刻这个效果，采用的是直接构建三维纹理，对模型坐标进行采样渲染，大致思路如下 思路1、修改cesium源码使其能够支持三维纹理，同时编写三维纹理类2、</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-12-16</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium-three/" class="post-category">cesium three</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0-%E4%BD%93%E6%B8%B2%E6%9F%93/"><span class="chip bg-color">柏林噪声 体渲染</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2023/12/16/mo-xing-bu-gui-ze-qu-yu-ya-ping/"><div class="card-image"><img src="https://bu.dusays.com/2023/12/16/657d9f9c2f24e.png" class="responsive-img" alt="模型不规则区域压平"> <span class="card-title">模型不规则区域压平</span></div></a><div class="card-content article-content"><div class="summary block-with-text">初版模型压平只实现了规则区域的压平效果，本文在此基础上优化，实现了不规则区域的压平，压平思路没有太大变化，主要是改进了范围判断的方法，使用射线法来判断模型坐标点是否在压平范围内，思路如下 思路1、将多边形的点数据依次传入到customSha</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-12-16</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/3dtiles-%E4%B8%8D%E8%A7%84%E5%88%99%E5%8C%BA%E5%9F%9F-%E5%8E%8B%E5%B9%B3/"><span class="chip bg-color">3dtiles 不规则区域 压平</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2023/10/26/cesium-mo-xing-ya-ping/"><div class="card-image"><img src="https://bu.dusays.com/2023/10/26/653a349fea9db.png" class="responsive-img" alt="模型压平"> <span class="card-title">模型压平</span></div></a><div class="card-content article-content"><div class="summary block-with-text">模型压平用的是cesium的customShader来编写的，目前只是实现了规则矩形区域压平，以及后续的闪面优化， 思路1、将矩形坐标范围通过customShader传入到着色器中2、矩形坐标转为模型坐标，并将其与模型坐标比较，将范围内模型</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-10-26</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/3dtiles-%E8%A7%84%E5%88%99%E5%8C%BA%E5%9F%9F-%E5%8E%8B%E5%B9%B3/"><span class="chip bg-color">3dtiles 规则区域 压平</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2023/10/06/cesium-san-wei-re-li-tu/"><div class="card-image"><img src="http://i1.hdslb.com/bfs/archive/63dd3855ebb4a796822b3f43ed5c55acfb4af616.jpg" class="responsive-img" alt="三维热力图"> <span class="card-title">三维热力图</span></div></a><div class="card-content article-content"><div class="summary block-with-text">使用cesium编写三维热力图效果，并在此基础上整合了水效果代码，当作优化一下可视化效果了hh 思路大致思路就是通过heatmap.js生成热力图，根据数据范围进行格网划分，并构造顶点数据，高度可以根据顶点在canvas上面的坐标读到的数值</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-10-06</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%83%AD%E5%8A%9B%E5%9B%BE-%E4%B8%89%E7%BB%B4/"><span class="chip bg-color">热力图 三维</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2023/09/26/cesium-chi-ping-xuan-ran/"><div class="card-image"><img src="https://bu.dusays.com/2023/10/04/651cd7fa49931.png" class="responsive-img" alt="离屏渲染"> <span class="card-title">离屏渲染</span></div></a><div class="card-content article-content"><div class="summary block-with-text">离屏渲染可以实现类似于小地图、飞行浏览的效果，本文通过帧缓冲以及webgl绘制纹理的方式实现将相机某个视角所看到的场景绘制到另一个canvas上 思路两个不同上下文的canvas是不能共用一份纹理资源的，但是可以通过读取帧缓冲中的纹理值，根</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-09-26</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%B8%A7%E7%BC%93%E5%86%B2-canvas/"><span class="chip bg-color">帧缓冲 canvas</span></a></div></div></div><div class="article col s12 m6 l4" data-aos="zoom-in"><div class="card"><a href="/2023/09/25/cesium-dian-guang-yuan/"><div class="card-image"><img src="https://i1.hdslb.com/bfs/archive/fddc26098431342cda77f95fcd682b056918bbd8.jpg" class="responsive-img" alt="点光源"> <span class="card-title">点光源</span></div></a><div class="card-content article-content"><div class="summary block-with-text">在cesium中要复刻three里面的点光源效果，大概有两种思路1、customShader编写光照计算2、后处理通过深度获取法线、坐标等计算 这里采用的customShader的方法计算，且光照计算比较简单，只计算了漫反射模型的结果后处理</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-09-25</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/cesium/" class="post-category">cesium</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%82%B9%E5%85%89%E6%BA%90-webgl/"><span class="chip bg-color">点光源 webgl</span></a></div></div></div></div></article></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2023-2024</span> <span id="year">2023</span> <a href="/about" target="_blank">John Doe</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><br><br></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/incheon0922" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="https://space.bilibili.com/311652727?spm_id_from=333.1007.0.0" class="tooltipped" target="_blank" data-tooltip="bilibili" data-position="top" data-delay="50"><i class="fab fa-bilibili"></i></a><a href="" class="tooltipped" target="_blank" data-tooltip="<img src='/wechat.jpg' width='128' height='148'/>" data-position="top" data-delay="50"><i class="fab fa-weixin"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$((function(){!function(t,e,r){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var n=$("entry",t).map((function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}})).get(),a=document.getElementById(e),s=document.getElementById(r);a.addEventListener("input",(function(){var t='<ul class="search-result-list">',e=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length<=0||(n.forEach((function(r){var n=!0,a=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url;i=0===i.indexOf("/")?r.url:"/"+i;var l=-1,c=-1,u=-1;if(""!==a&&""!==s&&e.forEach((function(t,e){l=a.indexOf(t),c=s.indexOf(t),l<0&&c<0?n=!1:(c<0&&(c=0),0===e&&(u=c))})),n){t+="<li><a href='"+i+"' class='search-result-title'>"+a+"</a>";var o=r.content.trim().replace(/<[^>]+>/g,"");if(u>=0){var h=u-20,f=u+80;h<0&&(h=0),0===h&&(f=100),f>o.length&&(f=o.length);var m=o.substr(h,f);e.forEach((function(t){var e=new RegExp(t,"gi");m=m.replace(e,'<em class="search-keyword">'+t+"</em>")})),t+='<p class="search-result">'+m+"...</p>"}t+="</li>"}})),t+="</ul>",s.innerHTML=t)}))}})}("/search.xml","searchInput","searchResult")}))</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/instantpage/instantpage.js" type="module"></script></body></html>